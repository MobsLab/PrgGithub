function AO = ReactRPairsHyper5(A)
% ReactRmatrices 
%
% computes the cell-pair correlation matrices R for sleep 1 sleep 2 and
% maze and the explained variance. The R matrices are "flattened" stored
% as column vectors (RpairC_s1, RpairC_s2, RpairC_m) corresponding to the
% correlation in cell pairs cell_I, cell_J. 
% This format is particularly convenient if data from several sessions
% are to be pooled together. 
% Inputs are the t files, and the start/end times for the epochs.
% outputs are the RpairC, cell_I, cell_J, and the EV.
% INPUTS
% filebase: stem for output fielnames  
% cell_list: name of a text file containing the names of the cells to use 
% epochs_start: vector containing the start times of sleep1, maze, sleep2
% epochs_end: vector containing the end times of sleep1, maze, sleep2
% restrict_times: cells array each element might be empty (and then
% no operation is performed) or it may contain a set of intervals, in that
% case the corresponding epoch will be restricted to the specified
% intervals. Useful to restrict maze time to actual runnign periods,
% sleep to spw periods, etc. 
  
  
  
  do_pyramids_only = 1;
  do_spw = 0;
  do_non_spw = 0;
  Qbin = 100 * 10; % the time bin for the Qmatrix (in 1/10000 sec)
  

  A = getResource(A, 'HippoCellList');
  A = getResource(A, 'HippoSpikeData');
  A = getResource(A, 'Maze_Epoch');
  Maze = Maze{1};
  A = getResource(A, 'Maze2_Epoch');
  Maze2 = Maze2{1};
  
  A = getResource(A, 'FRateMaze');
  A = getResource(A, 'FRateSleep1');
  A = getResource(A, 'FRateSleep2');
  
  
  A = getResource(A, 'Sleep1_10min_Epoch');  
  Sleep1 = Sleep1{1};
  
  A = getResource(A, 'Sleep2_10min_Epoch');    
  Sleep2 = Sleep2{1};
  
  A = getResource(A, 'Sleep2_2_10min_Epoch');    
  Sleep2_2 = Sleep2_2{1};

  A = getResource(A, 'Sleep3_10min_Epoch');    
  Sleep3 = Sleep3{1};

  A = getResource(A, 'SPW_s1');
  spw_s1 = spw_s1{1};
  no_spw_s1 = Sleep1 - spw_s1;
  
  A = getResource(A, 'SPW_s2');  
  spw_s2 = spw_s2{1};
  no_spw_s2 = Sleep2 - spw_s2;
  
  A = getResource(A, 'SPW_s3');  
  spw_s3 = spw_s3{1};
  no_spw_s2 = Sleep2 - spw_s2;
  
  n_cells = length(S);
  
 
  if do_pyramids_only
    
    A = registerResource(A, 'PairPyrEV', 'numeric', {1,1}, ...
			 'EV', ...
			 ['cell pair correlation explained variance', ...
		   'for the S1/M1/S2 epochs']);
    
    A = registerResource(A, 'PairPyrEVr', 'numeric', {1,1}, ...
			 'EVr', ...
			 ['cell pair correlation explained variance', ...
		   'for the S1/M1/S2 epochs']);
    A = registerResource(A, 'PairPyrEV2', 'numeric', {1,1}, ...
			 'EV2', ...
			 ['cell pair correlation explained variance', ...
		   'for the S2/M2/S3 epochs']);
    
    A = registerResource(A, 'PairPyrEVr2', 'numeric', {1,1}, ...
			 'EVr2', ...
			 ['cell pair correlation explained variance', ...
		   'for the S2/M2/S3 epochs']);
    A = registerResource(A, 'CellPairPyrI', 'numeric', {[], 1}, ...
			 'cell_I', ...
			 ['the index of the first cell in the pair, according' ...
		    ' to the order used in ReactR variables']);
    
    A = registerResource(A, 'CellPairPyrJ', 'numeric', {[], 1}, ...
			 'cell_J', ...
			 ['the index of the second cell in the pair, according' ...
		    ' to the order used in RP variables']);
    A = registerResource(A, 'RPairPyrCS1', 'numeric', {[],1}, ...
			 'RpairC_s1', ...
			 ['cell pair correlation during sleep1 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairPyrCS2', 'numeric', {[],1}, ...
			 'RpairC_s2', ...
			 ['cell pair correlation during sleep2 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairPyrCS2_2', 'numeric', {[],1}, ...
			 'RpairC_s2_2', ...
			 ['cell pair correlation during sleep2_2 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairPyrCS3', 'numeric', {[],1}, ...
			 'RpairC_s3', ...
			 ['cell pair correlation during sleep2 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairPyrCMaze', 'numeric', {[],1}, ...
			 'RpairC_m', ...
			 ['cell pair correlation during maze for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairPyrCMaze2', 'numeric', {[],1}, ...
			 'RpairC_m2', ...
			 ['cell pair correlation during maze2 for all' ...
		    ' viable cell pairs']);
    
  elseif do_spw

    A = registerResource(A, 'PairEVSPW', 'numeric', {1,1}, ...
			 'EV', ...
			 ['SPW cell pair correlation explained variance', ...
		    'for the S1/M1/S2 epochs']);
    
    A = registerResource(A, 'PairEVrSPW', 'numeric', {1,1}, ...
			 'EVr', ...
			 ['cell pair correlation explained variance', ...
		    'for the S1/M1/S2 epochs']);
    A = registerResource(A, 'PairEV2SPW', 'numeric', {1,1}, ...
			 'EV2', ...
			 ['SPW cell pair correlation explained variance', ...
		    'for the S2/M2/S3 epochs']);
    
    A = registerResource(A, 'PairEVr2SPW', 'numeric', {1,1}, ...
			 'EVr2', ...
			 ['cell pair correlation explained variance', ...
		    'for the S2/M2/S3 epochs']);
    A = registerResource(A, 'CellPairISPW', 'numeric', {[], 1}, ...
			 'cell_I', ...
			 ['SPW the index of the first cell in the pair, according' ...
		    ' to the order used in ReactR variables']);
    
    A = registerResource(A, 'CellPairJSPW', 'numeric', {[], 1}, ...
			 'cell_J', ...
			 ['SPW the index of the second cell in the pair, according' ...
		    ' to the order used in RP variables']);
    A = registerResource(A, 'RPairCS1SPW', 'numeric', {[],1}, ...
			 'RpairC_s1', ...
			 ['SPW cell pair correlation during sleep1 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCS2SPW', 'numeric', {[],1}, ...
			 'RpairC_s2', ...
			 ['SPW cell pair correlation during sleep2 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCS2_2SPW', 'numeric', {[],1}, ...
			 'RpairC_s2', ...
			 ['SPW cell pair correlation during sleep2_2 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCS3SPW', 'numeric', {[],1}, ...
			 'RpairC_s3', ...
			 ['SPW cell pair correlation during sleep3 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCMazeSPW', 'numeric', {[],1}, ...
			 'RpairC_m', ...
			 ['SPW cell pair correlation during maze for all' ...
		    ' viable cell pairs']);
     A = registerResource(A, 'RPairCMaze2SPW', 'numeric', {[],1}, ...
			 'RpairC_m2', ...
			 ['SPW cell pair correlation during maze2 for all' ...
		    ' viable cell pairs']);
   
  elseif do_non_spw

    A = registerResource(A, 'PairEVNoSPW', 'numeric', {1,1}, ...
			 'EV', ...
			 ['No SPW cell pair correlation explained variance', ...
		    'for the S1/M1/S2 epochs']);
    
    A = registerResource(A, 'PairEVrNoSPW', 'numeric', {1,1}, ...
			 'EVr', ...
			 ['cell pair correlation explained variance', ...
		    'for the S1/M1/S2 epochs']);
    A = registerResource(A, 'PairEV2NoSPW', 'numeric', {1,1}, ...
			 'EV2', ...
			 ['No SPW cell pair correlation explained variance', ...
		    'for the S2/M2/S3 epochs']);
    
    A = registerResource(A, 'PairEVr2NoSPW', 'numeric', {1,1}, ...
			 'EVr2', ...
			 ['cell pair correlation explained variance', ...
		    'for the S2/M2/S3 epochs']);
    A = registerResource(A, 'CellPairINoSPW', 'numeric', {[], 1}, ...
			 'cell_I', ...
			 ['No SPW the index of the first cell in the pair, according' ...
		    ' to the order used in ReactR variables']);
    
    A = registerResource(A, 'CellPairJNoSPW', 'numeric', {[], 1}, ...
			 'cell_J', ...
			 ['No SPW the index of the second cell in the pair, according' ...
		    ' to the order used in RP variables']);
    A = registerResource(A, 'RPairCS1NoSPW', 'numeric', {[],1}, ...
			 'RpairC_s1', ...
			 ['No SPW cell pair correlation during sleep1 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCS2NoSPW', 'numeric', {[],1}, ...
			 'RpairC_s2', ...
			 ['No SPW cell pair correlation during sleep2 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCS2_2NoSPW', 'numeric', {[],1}, ...
			 'RpairC_s2', ...
			 ['No SPW cell pair correlation during sleep2_2 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCS3NoSPW', 'numeric', {[],1}, ...
			 'RpairC_s3', ...
			 ['No SPW cell pair correlation during sleep3 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCMazeNoSPW', 'numeric', {[],1}, ...
			 'RpairC_m', ...
			 ['No SPW cell pair correlation during maze for all' ...
		    ' viable cell pairs']);
     A = registerResource(A, 'RPairCMaze2NoSPW', 'numeric', {[],1}, ...
			 'RpairC_m2', ...
			 ['No SPW cell pair correlation during maze2 for all' ...
		    ' viable cell pairs']);
   
    
    
    
    
  else
    
    
    A = registerResource(A, 'PairEV', 'numeric', {1,1}, ...
			 'EV', ...
			 ['cell pair correlation explained variance', ...
		    'for the S1/M1/S2 epochs']);
    
    A = registerResource(A, 'PairEVr', 'numeric', {1,1}, ...
			 'EVr', ...
			 ['cell pair correlation explained variance', ...
		    'for the S1/M1/S2 epochs']);
    A = registerResource(A, 'PairEV2', 'numeric', {1,1}, ...
			 'EV2', ...
			 ['cell pair correlation explained variance', ...
		    'for the S2/M2/S3 epochs']);
    
    A = registerResource(A, 'PairEVr2', 'numeric', {1,1}, ...
			 'EVr2', ...
			 ['cell pair correlation explained variance', ...
		    'for the S2/M2/S3 epochs']);
    A = registerResource(A, 'CellPairI', 'numeric', {[], 1}, ...
			 'cell_I', ...
			 ['the index of the first cell in the pair, according' ...
		    ' to the order used in ReactR variables']);
    
    A = registerResource(A, 'CellPairJ', 'numeric', {[], 1}, ...
			 'cell_J', ...
			 ['the index of the second cell in the pair, according' ...
		    ' to the order used in RP variables']);
    A = registerResource(A, 'RPairCS1', 'numeric', {[],1}, ...
			 'RpairC_s1', ...
			 ['cell pair correlation during sleep1 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCS2', 'numeric', {[],1}, ...
			 'RpairC_s2', ...
			 ['cell pair correlation during sleep2 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCS2_2', 'numeric', {[],1}, ...
			 'RpairC_s2_2', ...
			 ['cell pair correlation during sleep2_2 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCS3', 'numeric', {[],1}, ...
			 'RpairC_s3', ...
			 ['cell pair correlation during sleep3 for all' ...
		    ' viable cell pairs']);
    A = registerResource(A, 'RPairCMaze', 'numeric', {[],1}, ...
			 'RpairC_m', ...
			 ['cell pair correlation during sleep2 for all' ...
		    ' viable cell pairs']);
    
  end

  

  if do_pyramids_only
  
    f_ok = max([frate_maze frate_sleep1 frate_sleep2], [], 2) > ...
	   0.5;
    pyr =   f_ok;
    cellSet = pyr;
  else
    cellSet = 1:n_cells;
  end
  
  
 
  for i = 1:length(S)
    S_s1{i} = Restrict(S{i}, Sleep1);
    S_m{i} = Restrict(S{i}, Maze);
    S_s2{i} = Restrict(S{i}, Sleep2);
    S_s2_2{i} = Restrict(S{i}, Sleep2_2);
    S_m2{i} = Restrict(S{i}, Maze2);
    S_s3{i} = Restrict(S{i}, Sleep3);

  end
  
    
  
  
  
  % start calculations, the R matrices are transformed in a column
  % vector, containing only the matrix' lower triangle, and only the
  % correlations between cells not recorded on the same electrode
  % findOnSameTrodeMatrix is a function that looks at the tfiles
  % filenames and determines if they came from te same trode or not,
  % returning an output of the appropriate format for this code. 
  % the function DEPENDS on your very own convention for filenames, so go
  % look in there...
  % the outputs of this calculation are RpairC_m, RpairC_s1, RpairC_s2, (the
  % R matrices flattened in a vector, and purged of same trode stuff, and
  % cell_I, cell_J, two vectors indicating to which cell pairs the
  % correlations in the RpairCs corresponded to, useful if later you want
  % to recalculate the EVs only on subsets of cells.
  
  % notice that with the "eval" tricks you don't have to rewrite the code
  % for s1, m, s2
  
  
  sfx = { '_s1',  '_s2', '_s2_2', '_s3', '_m', '_m2'};
  
  [X, Y] = meshgrid(find(cellSet), find(cellSet));
  
  idx = find((~findOnSameTrodeMatrixHyper5(cellnames(find(cellSet)))) & (X > Y) );
  
  
  
  cell_I = X(idx);
  cell_J = Y(idx);
  
  
  for i = 1:6
    sf = sfx{i};
    
    eval(['S_epoch = S' sf ';']);
    Q = MakeQfromS(S_epoch, Qbin);

    Q = tsd(Range(Q, 'ts'), full(Data(Q)));
    
    if i < 5 & do_spw
      eval(['sw = spw' sf ';']);
      
      Q = Restrict(Q, sw);
    elseif i < 5 & do_non_spw
      eval(['sw = no_spw' sf ';']);
      
      Q = Restrict(Q, sw);
    end % if i < 5 & do_spw

    
    
    warning off
    cQ = corrcoef(Data(Q));
    warning on
    RpairC = full(cQ(idx));
    
    
    eval(['RpairC' sf ' = RpairC;']);

     
    clear Q cQ RpairC

  end
    
 
 
  
  % now compute the explained variance: ReactEV computes the partial
  % correlation coefficients, taking care of NaNs  that arise from
  % correlations from empty spike trains
%  keyboard

  warning off
  [EV EVr] = ReactEV(RpairC_s1, RpairC_s2, RpairC_m);
  [EV2 EVr2] = ReactEV(RpairC_s2_2, RpairC_s3, RpairC_m2);
  warning on  
  
  
 
  
  A = saveAllResources(A);
  
  AO = A;
  
function pathIntegratorNet()


% switches
% "plasticity": this is the plasticity on the lateral connection layer 
%     "HebbianRecurrent": hebbian plasticity on the recurrent 
%           parameters:
%               deltaJ: plasticity increment, it is normalized by the
%               standard deviation of the synaptic matrix elements
%     "None": no plasticity, the lateral connection are fixed
% "SynapticMatrix": the initial structure of the matrix
%     "LoadJComp": Load the synaptic matrix generated by the simulation HexLearn
%     "Load": load a pre-wired synaptic matrix with a mexican-hat structure, in the file SMatrix  
%     "MexicanHat" generate a mexican hat structure (and save it in the
%          file SMatrix. Cells are placed on the points of a square grid
%    "TriangularPeriodic": generate a matrix wher cells are placed at
%          random on a triangular grid. Mexican hat connections are produced with the periodicity. Asymmetric 
%          connections are added to create the path itnegation mechanism
%   "Random": random synapses, fractionActiveSynapses are active and distributed exponentially, normalized so that 
%          each row sum up on average to 1
% "Initialization": initial state of network activity
%    "ToMap": initialize the network in a state where only cells in the center of grid
%         cell are active.  This is still a bit of a problem: the system takes a while to settle on
%          the activity packet-attractor
%    "Random": random activity 
%    "GridTemplate": A template grid is established on the lower level, and
%         "trasfered to the simulated layer through the feedforward
%         connections

Simulation = 'TriangularPathIntegrator';
%Simulation = 'HexAdapt';
%Simulation = 'HexLearn';
%Simulation = 'FormedGrid';
Simulation = 'ThetaDendrites';


switch Simulation
         

    case 'ThetaDendrites'
        % this caused OK path integration but, a lot of transition to "head
        % direction" state

        synapticMatrix = 'None';

        initialization = 'ThetaInit';

        outputDisplay = 'ThetaOneCellVideo';
        tVideoInit = 60;
        tVideoEnd = 500;

        externalInput = 'HeadDirectionTheta';

        plasticity = 'None';

        output = 'None';

        InhibitionType= 'None';

        VideoFeatures = {'RatVideo'}; % TODO
        %%%% parameters for the simulations

        % THETA PARAMETERS
        
%         latticeSpacing = 40; % unit is "centimeters"
%         connectionSpan = 7.5; % the spread of the conncetion matrix

        omega = 0.1; % the "pulsation" of the rythm
        nDend = 6;
        N = 1;  % the number of cells
        nSteps =2000000; % the number of random walk steps
        cageSize = 100; % the size of the rat "cage"
   

%         fixAct = 2; % the maximum average activity allowed by the inhibition mechanism
%         gamma = 1.1; % the relative importance of the asymmetric component in the synapric matrix
        dT = 1; % time step at each iteration (a bit redundant, in practise we keep it at one)
        tau = 50; % the time constant

        dirStrength = 0.3; % the strength of the directional input
        nonDirInput = 0;


%         % neural adaptation is modeled as a subtractive term that
%         %depends on the activity in the last Tadapt time steps (linearly decaying) and
%         % with a strength Kadapt: A = - (Kadapt/Tadapt) \int_{t-Tadapt}^{t} dt' V(t') (t'-t+Tadapt)
         Tadapt = 500;
         Kadapt = 0.5;

        % we save the activity every monitorStep time steps
        monitorStep = 1;

        
        
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



if strcmp(externalInput, 'GridPlace') | strcmp(outputDisplay, 'VideoImage')
    load Jcomp
    ix = find(sum(Vtot,1) >80);
    N = length(ix);
    Vtot = Vtot(:,ix);
end




 % the preferred direction for each cell, uniformly distributed on [0, 2 \pi]
        phi = rand(1,N)*2*pi;


        % The versor for each cell
        dirCell = [cos(phi) ; sin(phi)];



 
 Vi = zeros(N,1);
 Va = zeros(N, 10);
 Vadapt=zeros(N, Tadapt);
 

 switch initialization

     case 'ToMap'
         %initialize the network in a state where only cells in the center of grid
         %cell are active
         % this is still a bit of a problem: the system takes a while to settle on
         % the activity packet-attractor


         Vi = 3* exp(-sqrt((x).^2+(y).^2)/(latticeSpacing/10));
         Vi / mean(Vi) * fixAct;
         Vi = Vi';
     case 'Random'
         %Vi = 20 * exprnd(1, N, 1);
         Vi = 0.02* rand(N, 1);
     case 'GridTemplate'
         load gridTemplate
         side = 50;
         px = 1;
         py = 1;
         Vin = gridTemplate(px:(px+side-1),py:(py+side-1));
         Jcomp = Jcomp(ix,:);
          Jcomp = Jcomp/size(Jcomp, 2);
         Vi = placeInputStrength * Jcomp * Vin(:);
         
     case 'ThetaInit'
         HexBasis = [ 1, 0
                                1/2, sqrt(3)/2 ;
                                -1/2, sqrt(3)/2 ; 
                                -1, 0 ; 
                                -1/2, -sqrt(3)/2;
                                1/2, -sqrt(3)/2];
                            
         dirCell = repmat(HexBasis', [1 1 N]);
         
         % all the rest of the initialization stuff goes in there TODO                      
         Aalpha = ones(N, nDend);
         Ualpha = ones(N, 1);
         phiAlpha = zeros(N,1);
         extInp = zeros(N,nDend);
 end

% save the history of the activity configurations
Vconf = zeros(N, floor(nSteps)/monitorStep, 'single');

% generate the rat trajectory
dbclear all
[xRat, yRat] = randomWalk(nSteps+500, cageSize);
xRat = xRat(501:end);
yRat = yRat(501:end);


% instantaneous rat speed 
vRat = [diff(xRat) ; diff(yRat)];

xRat = xRat(2:end);
yRat = yRat(2:end);

% for the adaptation calculation 
adaptScale = (linspace(0, Kadapt/Tadapt, Tadapt))';
mm = 0;

 if strcmp(externalInput, 'GridPlace')
         Jcomp = Jcomp/size(Jcomp, 2);
     Jcomp = Jcomp(ix,:);
     phaseX = ceil(xRat);
     phaseY = ceil(yRat);
 end
tic



% main simulation loop
 for ns = 1:(nSteps-1)

     mm = mod(ns, Tadapt);
     if(mm == Tadapt)
         mm = 0;
     end

     % adaptation: Vadapt is a "ring buffer" so that we optimize away 
     as = [adaptScale(end-mm:end) ; adaptScale(1:(end-mm-1))];
     A = Vadapt * as;
    
    % save previous configuration
    Viold = Vi;
    
    
    switch externalInput
   
            
        case 'HeadDirectionTheta'
            
            for i = 1:N
                extInp(i,:)=  nonDirInput + dirStrength * (vRat(:,ns))' * squeeze(dirCell(:,:,i));
                [xx, ix] = sort(extInp(i,:));
                extInp(i,ix(1:end-2)) = 0;
            end
            
               
                
                
            
        case 'Ramp'
            extInp = ones(size(N)) *  (ns/nSteps) * rampInputStrength;
           
        case 'Constant'
            extInp = ones(size(N)) * constInputStrength;
            
        case '2DPlace'
            d = sqrt((xInp - xRat(ns)) .^ 2 +  (yInp - yRat(ns)).^2);
            extInp = constInputStrength + placeInputStrength * Jinp * exp(-d/inputActivationSpread);
            
        case 'GridPlace'
            load gridTemplate
            % we move to a different input phase every monitorStep steps
            if mod(ns, monitorStep) == 1
                px = phaseX(ceil(ns/monitorStep));
                py = phaseY(ceil(ns/monitorStep));
                Vin = gridTemplate(px:(px+side-1),py:(py+side-1));
                extInp = placeInputStrength * Jcomp * Vin(:);
            end
    end
     
    phiAlpha = phiAlpha + omega * dT + extInp;
    Vi = sum(Aalpha .* cos(phiAlpha)) + Ualpha;
    
    


    if(ns > 20)
        2;
    end
    
    

    
    % save activity
    mm = mod(ns, monitorStep);
    if mm == 0
        mm = monitorStep;
    end
    Va(:,mm) = Vi;

    
    
    
    %every monitorStep steps average activtiy and store the result in Vconf
    if mm == monitorStep
        Vconf(:,ns/monitorStep) = mean(Va, 2);

    end

   
    
 
    
    % save buffer for adaptation

 
        
 end
 

 toc
 
dx = dirCell(1,:);
dy = dirCell(2,:);

vr = vRat(:,1:monitorStep:end);
xx = xRat(1:monitorStep:end);
yy = yRat(1:monitorStep:end);

 np = 1;

 if strcmp(Simulation, 'HexLearn')
     save SMatrix J
 end
 
keyboard
 save Vconf Vconf x  y monitorStep xRat yRat xx yy
 
 
 switch outputDisplay

     case 'FiringRateInfo'
         for phase = 1:nInfoSteps:nSteps
             vc = Vconf(:,phase:(phase+nInfoSteps-1));
             n = 1;
             for i = 1:10:N
                 fmap = ndAverage([xx;yy], vc(i,:), [40;40], [0;0], [cageSize; cageSize]);
                 fnorm = ndHist([xx;yy], [40;40], [0;0], [cageSize; cageSize]);
                 ix = find(isfinite(fmap) & fnorm > 0);
                 fmap = fmap(ix)+ eps;
                 fnorm = fnorm(ix);
                 frate = sum(fmap .* fnorm) / sum(fnorm);
                 I(phase,n) = sum(fmap.*log(fmap/frate) .* fnorm) / sum(fnorm); 
                 n = n+1;
                 
             end
             for i = 1:50:N
                 fmap = ndAverage([xx;yy], Vconf(i,:), [40;40], [0;0], [cageSize; cageSize]);
                 imagesc(fmap);
                 keyboard
             end
         end


     case 'FiringRateMaps'
         for i = 1:50:N
             fmap = ndAverage([xx;yy], Vconf(i,:), [40;40], [0;0], [cageSize; cageSize]);
             imagesc(fmap);
             keyboard
         end
         
     case 'VideoImage'
            
            tInit = 1;
            %tEnd = nSteps/monitorStep;
            tEnd = 5000/monitorStep;
            nConf = size(Vtot, 1);
            side  = sqrt(nConf);
            for i = tInit:10:tEnd
                vv = (Vconf(:,i))';
                vvk = repmat(vv, nConf,1);
                acPack = sum(Vtot .* vvk, 2);
                acPack = reshape(acPack, 50, 50);
                imagesc(acPack)
                hold on 
                text(20, 25, num2str(i));
                hold off 
                M(np) = getframe;
                np = np+1;
            end
            keyboard
         movie2avi(M, 'Packet.avi', 'FPS', 6, 'COMPRESSION', 'None');
     case 'Video'
           tInit = tVideoInit;
           tEnd = tVideoEnd;
         %video generation
         for i = tInit:tEnd
             
             
             plotColors(x, y, Vconf(:,i)), axis equal % activation as a function of position on the grid
             hold on;
             axis([-40 40 -30 30]);
             if ismember('RatVideo', VideoFeatures)
                 plot(-30 + 10*cos(0:0.1:2*pi), 20 + 10* sin(0:0.1:2*pi)); % Rat inst. speed
                 plot([-30, -30+50*vr(1,i)], [20, 20+50*vr(2,i)])
                 plotColors(-30+10*dx, -20+10*dy, Vconf(:,i)); % activation as a fucntion of directional preference
                 
                 % rat position
                 plot([20 40], [-10 -10 ]);
                 plot([20 20], [-10 -30]);
                 mi = max(i-50, tInit);
                 plot(xx(mi:i)/5+20, yy(mi:i)/5-30);
                 plot(xx(i)/5+20, yy(i)/5-30, 'r.');
             end
             text(20, 25, num2str(i));
             hold off
             M(np) = getframe;
             np = np+1;
         end
        
        save simOutput Vconf dirCell 
         movie2avi(M, 'Packet.avi', 'FPS', 6, 'COMPRESSION', 'None');
     case 'None'
         ;
 end

 
 if strcmp(output, 'CompLearn')
     save Jcomp Jcomp
     keyboard
 end
 
